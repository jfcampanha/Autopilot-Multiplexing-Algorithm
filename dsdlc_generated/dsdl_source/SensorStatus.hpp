/*
 * UAVCAN data structure definition for libuavcan.
 *
 * Autogenerated, do not edit.
 *
 * Source file: /home/joao/PESTA/control_system/v1/dsdl_source/20986.SensorStatus.uavcan
 */

#ifndef DSDL_SOURCE_SENSORSTATUS_HPP_INCLUDED
#define DSDL_SOURCE_SENSORSTATUS_HPP_INCLUDED

#include <uavcan/build_config.hpp>
#include <uavcan/node/global_data_type_registry.hpp>
#include <uavcan/marshal/types.hpp>

/******************************* Source text **********************************
#
# Generic status message to report the status of all sensors available to the autopilot
#

#
# Autopilot Index
#
uint8 autopilot_index

#
# General status flags for all autopilot sensors
# Present - Identifies which sensors are available on the autopilot
# Enable - Identifies which sensors are enabled on the autopilot
# Healthy - Identifies the health status of each sensor on the autopilot
#
uint32 present
uint32 enable
uint32 healthy

#
# Accelerometer flags
#
uint32 FLAG_SENSOR_3D_ACCEL1 = 1
uint32 FLAG_SENSOR_3D_ACCEL2 = 2
uint32 FLAG_SENSOR_3D_ACCEL3 = 4
#
# Gyroscope flags
#
uint32 FLAG_SENSOR_3D_GYRO1 = 8
uint32 FLAG_SENSOR_3D_GYRO2 = 16
uint32 FLAG_SENSOR_3D_GYRO3 = 32
#
# Magnetometer flags
#
uint32 FLAG_SENSOR_3D_MAG1 = 64
uint32 FLAG_SENSOR_3D_MAG2 = 128
uint32 FLAG_SENSOR_3D_MAG3 = 256
#
# Barometer flags
#
uint32 FLAG_SENSOR_ABSOLUTE_PRESSURE1 = 512
uint32 FLAG_SENSOR_ABSOLUTE_PRESSURE2 = 1024
uint32 FLAG_SENSOR_ABSOLUTE_PRESSURE3 = 2048
#
# Airspeed flags
#
uint32 FLAG_SENSOR_DIFFERENTIAL_PRESSURE1 = 4096
uint32 FLAG_SENSOR_DIFFERENTIAL_PRESSURE2 = 8192
uint32 FLAG_SENSOR_DIFFERENTIAL_PRESSURE3 = 16384
#
# GNSS flags
#
uint32 FLAG_STATUS_SENSOR_GNSS1 = 32768
uint32 FLAG_STATUS_SENSOR_GNSS2 = 65536
#
# RC Transmitter flags
#
uint32 FLAG_SENSOR_RC_RECEIVER1 = 131072
uint32 FLAG_SENSOR_RC_RECEIVER2 = 262144
#
# Lidar for terrain altitude flag
#
uint32 FLAG_SENSOR_LIDAR = 524288
#
# Battery flag
#
uint32 FLAG_SENSOR_BATTERY = 1048576
#
# Energy Management Unit flag
#
uint32 FLAG_SENSOR_EMU = 2097152
#
# Lightning flag
#
uint32 FLAG_SENSOR_LIGHTNING = 4194304
******************************************************************************/

/********************* DSDL signature source definition ***********************
dsdl_source.SensorStatus
saturated uint8 autopilot_index
saturated uint32 present
saturated uint32 enable
saturated uint32 healthy
******************************************************************************/

#undef autopilot_index
#undef present
#undef enable
#undef healthy
#undef FLAG_SENSOR_3D_ACCEL1
#undef FLAG_SENSOR_3D_ACCEL2
#undef FLAG_SENSOR_3D_ACCEL3
#undef FLAG_SENSOR_3D_GYRO1
#undef FLAG_SENSOR_3D_GYRO2
#undef FLAG_SENSOR_3D_GYRO3
#undef FLAG_SENSOR_3D_MAG1
#undef FLAG_SENSOR_3D_MAG2
#undef FLAG_SENSOR_3D_MAG3
#undef FLAG_SENSOR_ABSOLUTE_PRESSURE1
#undef FLAG_SENSOR_ABSOLUTE_PRESSURE2
#undef FLAG_SENSOR_ABSOLUTE_PRESSURE3
#undef FLAG_SENSOR_DIFFERENTIAL_PRESSURE1
#undef FLAG_SENSOR_DIFFERENTIAL_PRESSURE2
#undef FLAG_SENSOR_DIFFERENTIAL_PRESSURE3
#undef FLAG_STATUS_SENSOR_GNSS1
#undef FLAG_STATUS_SENSOR_GNSS2
#undef FLAG_SENSOR_RC_RECEIVER1
#undef FLAG_SENSOR_RC_RECEIVER2
#undef FLAG_SENSOR_LIDAR
#undef FLAG_SENSOR_BATTERY
#undef FLAG_SENSOR_EMU
#undef FLAG_SENSOR_LIGHTNING

namespace dsdl_source
{

template <int _tmpl>
struct UAVCAN_EXPORT SensorStatus_
{
    typedef const SensorStatus_<_tmpl>& ParameterType;
    typedef SensorStatus_<_tmpl>& ReferenceType;

    struct ConstantTypes
    {
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_3D_ACCEL1;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_3D_ACCEL2;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_3D_ACCEL3;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_3D_GYRO1;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_3D_GYRO2;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_3D_GYRO3;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_3D_MAG1;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_3D_MAG2;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_3D_MAG3;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_ABSOLUTE_PRESSURE1;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_ABSOLUTE_PRESSURE2;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_ABSOLUTE_PRESSURE3;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_DIFFERENTIAL_PRESSURE1;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_DIFFERENTIAL_PRESSURE2;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_DIFFERENTIAL_PRESSURE3;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_STATUS_SENSOR_GNSS1;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_STATUS_SENSOR_GNSS2;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_RC_RECEIVER1;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_RC_RECEIVER2;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_LIDAR;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_BATTERY;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_EMU;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > FLAG_SENSOR_LIGHTNING;
    };

    struct FieldTypes
    {
        typedef ::uavcan::IntegerSpec< 8, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > autopilot_index;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > present;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > enable;
        typedef ::uavcan::IntegerSpec< 32, ::uavcan::SignednessUnsigned, ::uavcan::CastModeSaturate > healthy;
    };

    enum
    {
        MinBitLen
            = FieldTypes::autopilot_index::MinBitLen
            + FieldTypes::present::MinBitLen
            + FieldTypes::enable::MinBitLen
            + FieldTypes::healthy::MinBitLen
    };

    enum
    {
        MaxBitLen
            = FieldTypes::autopilot_index::MaxBitLen
            + FieldTypes::present::MaxBitLen
            + FieldTypes::enable::MaxBitLen
            + FieldTypes::healthy::MaxBitLen
    };

    // Constants
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_3D_ACCEL1 >::Type FLAG_SENSOR_3D_ACCEL1; // 1
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_3D_ACCEL2 >::Type FLAG_SENSOR_3D_ACCEL2; // 2
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_3D_ACCEL3 >::Type FLAG_SENSOR_3D_ACCEL3; // 4
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_3D_GYRO1 >::Type FLAG_SENSOR_3D_GYRO1; // 8
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_3D_GYRO2 >::Type FLAG_SENSOR_3D_GYRO2; // 16
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_3D_GYRO3 >::Type FLAG_SENSOR_3D_GYRO3; // 32
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_3D_MAG1 >::Type FLAG_SENSOR_3D_MAG1; // 64
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_3D_MAG2 >::Type FLAG_SENSOR_3D_MAG2; // 128
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_3D_MAG3 >::Type FLAG_SENSOR_3D_MAG3; // 256
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_ABSOLUTE_PRESSURE1 >::Type FLAG_SENSOR_ABSOLUTE_PRESSURE1; // 512
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_ABSOLUTE_PRESSURE2 >::Type FLAG_SENSOR_ABSOLUTE_PRESSURE2; // 1024
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_ABSOLUTE_PRESSURE3 >::Type FLAG_SENSOR_ABSOLUTE_PRESSURE3; // 2048
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_DIFFERENTIAL_PRESSURE1 >::Type FLAG_SENSOR_DIFFERENTIAL_PRESSURE1; // 4096
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_DIFFERENTIAL_PRESSURE2 >::Type FLAG_SENSOR_DIFFERENTIAL_PRESSURE2; // 8192
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_DIFFERENTIAL_PRESSURE3 >::Type FLAG_SENSOR_DIFFERENTIAL_PRESSURE3; // 16384
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_STATUS_SENSOR_GNSS1 >::Type FLAG_STATUS_SENSOR_GNSS1; // 32768
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_STATUS_SENSOR_GNSS2 >::Type FLAG_STATUS_SENSOR_GNSS2; // 65536
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_RC_RECEIVER1 >::Type FLAG_SENSOR_RC_RECEIVER1; // 131072
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_RC_RECEIVER2 >::Type FLAG_SENSOR_RC_RECEIVER2; // 262144
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_LIDAR >::Type FLAG_SENSOR_LIDAR; // 524288
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_BATTERY >::Type FLAG_SENSOR_BATTERY; // 1048576
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_EMU >::Type FLAG_SENSOR_EMU; // 2097152
    static const typename ::uavcan::StorageType< typename ConstantTypes::FLAG_SENSOR_LIGHTNING >::Type FLAG_SENSOR_LIGHTNING; // 4194304

    // Fields
    typename ::uavcan::StorageType< typename FieldTypes::autopilot_index >::Type autopilot_index;
    typename ::uavcan::StorageType< typename FieldTypes::present >::Type present;
    typename ::uavcan::StorageType< typename FieldTypes::enable >::Type enable;
    typename ::uavcan::StorageType< typename FieldTypes::healthy >::Type healthy;

    SensorStatus_()
        : autopilot_index()
        , present()
        , enable()
        , healthy()
    {
        ::uavcan::StaticAssert<_tmpl == 0>::check();  // Usage check

#if UAVCAN_DEBUG
        /*
         * Cross-checking MaxBitLen provided by the DSDL compiler.
         * This check shall never be performed in user code because MaxBitLen value
         * actually depends on the nested types, thus it is not invariant.
         */
        ::uavcan::StaticAssert<104 == MaxBitLen>::check();
#endif
    }

    bool operator==(ParameterType rhs) const;
    bool operator!=(ParameterType rhs) const { return !operator==(rhs); }

    /**
     * This comparison is based on @ref uavcan::areClose(), which ensures proper comparison of
     * floating point fields at any depth.
     */
    bool isClose(ParameterType rhs) const;

    static int encode(ParameterType self, ::uavcan::ScalarCodec& codec,
                      ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    static int decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
                      ::uavcan::TailArrayOptimizationMode tao_mode = ::uavcan::TailArrayOptEnabled);

    /*
     * Static type info
     */
    enum { DataTypeKind = ::uavcan::DataTypeKindMessage };
    enum { DefaultDataTypeID = 20986 };

    static const char* getDataTypeFullName()
    {
        return "dsdl_source.SensorStatus";
    }

    static void extendDataTypeSignature(::uavcan::DataTypeSignature& signature)
    {
        signature.extend(getDataTypeSignature());
    }

    static ::uavcan::DataTypeSignature getDataTypeSignature();

};

/*
 * Out of line struct method definitions
 */

template <int _tmpl>
bool SensorStatus_<_tmpl>::operator==(ParameterType rhs) const
{
    return
        autopilot_index == rhs.autopilot_index &&
        present == rhs.present &&
        enable == rhs.enable &&
        healthy == rhs.healthy;
}

template <int _tmpl>
bool SensorStatus_<_tmpl>::isClose(ParameterType rhs) const
{
    return
        ::uavcan::areClose(autopilot_index, rhs.autopilot_index) &&
        ::uavcan::areClose(present, rhs.present) &&
        ::uavcan::areClose(enable, rhs.enable) &&
        ::uavcan::areClose(healthy, rhs.healthy);
}

template <int _tmpl>
int SensorStatus_<_tmpl>::encode(ParameterType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    int res = 1;
    res = FieldTypes::autopilot_index::encode(self.autopilot_index, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::present::encode(self.present, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::enable::encode(self.enable, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::healthy::encode(self.healthy, codec,  tao_mode);
    return res;
}

template <int _tmpl>
int SensorStatus_<_tmpl>::decode(ReferenceType self, ::uavcan::ScalarCodec& codec,
    ::uavcan::TailArrayOptimizationMode tao_mode)
{
    (void)self;
    (void)codec;
    (void)tao_mode;
    int res = 1;
    res = FieldTypes::autopilot_index::decode(self.autopilot_index, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::present::decode(self.present, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::enable::decode(self.enable, codec,  ::uavcan::TailArrayOptDisabled);
    if (res <= 0)
    {
        return res;
    }
    res = FieldTypes::healthy::decode(self.healthy, codec,  tao_mode);
    return res;
}

/*
 * Out of line type method definitions
 */
template <int _tmpl>
::uavcan::DataTypeSignature SensorStatus_<_tmpl>::getDataTypeSignature()
{
    ::uavcan::DataTypeSignature signature(0x727648A7F1D0BC9ULL);

    FieldTypes::autopilot_index::extendDataTypeSignature(signature);
    FieldTypes::present::extendDataTypeSignature(signature);
    FieldTypes::enable::extendDataTypeSignature(signature);
    FieldTypes::healthy::extendDataTypeSignature(signature);

    return signature;
}

/*
 * Out of line constant definitions
 */

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_3D_ACCEL1 >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_3D_ACCEL1 = 1U; // 1

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_3D_ACCEL2 >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_3D_ACCEL2 = 2U; // 2

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_3D_ACCEL3 >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_3D_ACCEL3 = 4U; // 4

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_3D_GYRO1 >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_3D_GYRO1 = 8U; // 8

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_3D_GYRO2 >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_3D_GYRO2 = 16U; // 16

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_3D_GYRO3 >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_3D_GYRO3 = 32U; // 32

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_3D_MAG1 >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_3D_MAG1 = 64U; // 64

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_3D_MAG2 >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_3D_MAG2 = 128U; // 128

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_3D_MAG3 >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_3D_MAG3 = 256U; // 256

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_ABSOLUTE_PRESSURE1 >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_ABSOLUTE_PRESSURE1 = 512U; // 512

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_ABSOLUTE_PRESSURE2 >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_ABSOLUTE_PRESSURE2 = 1024U; // 1024

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_ABSOLUTE_PRESSURE3 >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_ABSOLUTE_PRESSURE3 = 2048U; // 2048

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_DIFFERENTIAL_PRESSURE1 >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_DIFFERENTIAL_PRESSURE1 = 4096U; // 4096

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_DIFFERENTIAL_PRESSURE2 >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_DIFFERENTIAL_PRESSURE2 = 8192U; // 8192

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_DIFFERENTIAL_PRESSURE3 >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_DIFFERENTIAL_PRESSURE3 = 16384U; // 16384

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_STATUS_SENSOR_GNSS1 >::Type
    SensorStatus_<_tmpl>::FLAG_STATUS_SENSOR_GNSS1 = 32768U; // 32768

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_STATUS_SENSOR_GNSS2 >::Type
    SensorStatus_<_tmpl>::FLAG_STATUS_SENSOR_GNSS2 = 65536U; // 65536

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_RC_RECEIVER1 >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_RC_RECEIVER1 = 131072U; // 131072

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_RC_RECEIVER2 >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_RC_RECEIVER2 = 262144U; // 262144

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_LIDAR >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_LIDAR = 524288U; // 524288

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_BATTERY >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_BATTERY = 1048576U; // 1048576

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_EMU >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_EMU = 2097152U; // 2097152

template <int _tmpl>
const typename ::uavcan::StorageType< typename SensorStatus_<_tmpl>::ConstantTypes::FLAG_SENSOR_LIGHTNING >::Type
    SensorStatus_<_tmpl>::FLAG_SENSOR_LIGHTNING = 4194304U; // 4194304

/*
 * Final typedef
 */
typedef SensorStatus_<0> SensorStatus;

namespace
{

const ::uavcan::DefaultDataTypeRegistrator< ::dsdl_source::SensorStatus > _uavcan_gdtr_registrator_SensorStatus;

}

} // Namespace dsdl_source

/*
 * YAML streamer specialization
 */
namespace uavcan
{

template <>
class UAVCAN_EXPORT YamlStreamer< ::dsdl_source::SensorStatus >
{
public:
    template <typename Stream>
    static void stream(Stream& s, ::dsdl_source::SensorStatus::ParameterType obj, const int level);
};

template <typename Stream>
void YamlStreamer< ::dsdl_source::SensorStatus >::stream(Stream& s, ::dsdl_source::SensorStatus::ParameterType obj, const int level)
{
    (void)s;
    (void)obj;
    (void)level;
    if (level > 0)
    {
        s << '\n';
        for (int pos = 0; pos < level; pos++)
        {
            s << "  ";
        }
    }
    s << "autopilot_index: ";
    YamlStreamer< ::dsdl_source::SensorStatus::FieldTypes::autopilot_index >::stream(s, obj.autopilot_index, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "present: ";
    YamlStreamer< ::dsdl_source::SensorStatus::FieldTypes::present >::stream(s, obj.present, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "enable: ";
    YamlStreamer< ::dsdl_source::SensorStatus::FieldTypes::enable >::stream(s, obj.enable, level + 1);
    s << '\n';
    for (int pos = 0; pos < level; pos++)
    {
        s << "  ";
    }
    s << "healthy: ";
    YamlStreamer< ::dsdl_source::SensorStatus::FieldTypes::healthy >::stream(s, obj.healthy, level + 1);
}

}

namespace dsdl_source
{

template <typename Stream>
inline Stream& operator<<(Stream& s, ::dsdl_source::SensorStatus::ParameterType obj)
{
    ::uavcan::YamlStreamer< ::dsdl_source::SensorStatus >::stream(s, obj, 0);
    return s;
}

} // Namespace dsdl_source

#endif // DSDL_SOURCE_SENSORSTATUS_HPP_INCLUDED